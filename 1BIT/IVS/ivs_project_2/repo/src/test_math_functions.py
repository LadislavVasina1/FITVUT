## @file test_math_functions.py
#  @brief Tests for mathematical functions.
#
#  This contains all property based unit tests for mathematical functions
#  used in our callculator app. Test are written for all acepted input
#  types of each math function. Used testing framwork is pytest alongside
#  the hypothesis library.
#
#  All tests test for the general functionality of given funciton plus
#  properties if has some. Some function have multiple test with different
#  types of inputs generated by hypothesis. Test are run with the
#  verbosity setting (each input can be written to output) that can be
#  toggled with "-s" option when run with pytest.
#
#  @author Dominik VÃ¡gner
#  @date 09/04/2021

import pytest
from hypothesis import assume, given, settings, Verbosity
import hypothesis.strategies as st
from math import isnan, isclose, factorial, pow

import math_functions as m_func

## Test case for add() function with integer type inputs
#  @param num1 Integer number
#  @param num2 Integer number
@settings(verbosity=Verbosity.verbose)
@given(st.integers(), st.integers())
def test_add_integers(num1, num2):
    # General test
    assert m_func.add(num1, num2) == num1 + num2
    # Test Indentity property
    assert m_func.add(num1, 0) == num1
    # Test Commutative property
    assert m_func.add(num1, num2) == m_func.add(num2, num1)
    # Test Associative property
    assert m_func.add(num1, m_func.add(num1, num2)) == \
        m_func.add(m_func.add(num1, num1), num2)

## Test case for add() function with float type inputs
#  @param num1 Floating point number
#  @param num2 Floating point number
@settings(verbosity=Verbosity.verbose)
@given(st.floats(), st.floats())
def test_add_floats(num1, num2):
    if isnan(num1 + num2):
        with pytest.raises(ValueError):
            m_func.add(num1, num2)
    else:
        # General test
        assert m_func.add(num1, num2) == num1 + num2
        # Test Indentity property
        assert m_func.add(num1, 0) == num1
        # Test Commutative property
        assert m_func.add(num1, num2) == m_func.add(num2, num1)

## Test case for subtract() function with integer type inputs
#  @param num1 Integer number
#  @param num2 Integer number
@settings(verbosity=Verbosity.verbose)
@given(st.integers(), st.integers())
def test_substract_integers(num1, num2):
    # General test
    assert m_func.subtract(num1, num2) == num1 - num2
    # Test Indentity property
    assert m_func.subtract(num1, 0) == num1
    # Substract from itself equals 0
    assert m_func.subtract(num1, num1) == 0
    assert m_func.subtract(num2, num2) == 0

## Test case for subtract() function with float type inputs
#  @param num1 Floating point number
#  @param num2 Floating point number
@settings(verbosity=Verbosity.verbose)
@given(st.floats(), st.floats())
def test_subtract_floats(num1, num2):
    if isnan(num1 - num2):
        with pytest.raises(ValueError):
            m_func.subtract(num1, num2)
    else:
        # General test
        assert m_func.subtract(num1, num2) == num1 - num2
        # Test Indentity property
        assert m_func.subtract(num1, 0) == num1

## Test case for multiply() function with integer type inputs
#  @param num1 Integer number
#  @param num2 Integer number
@settings(verbosity=Verbosity.verbose)
@given(st.integers(), st.integers())
def test_multiply_integers(num1, num2):
    # General test
    assert m_func.multiply(num1, num2) == num1 * num2
    # Test Indentity property
    assert m_func.multiply(num1, 1) == num1
    # Test Commutative property
    assert m_func.multiply(num1, num2) == m_func.multiply(num2, num1)
    # Test Associative property
    assert m_func.multiply(num1, m_func.multiply(num1, num2)) == \
        m_func.multiply(m_func.multiply(num1, num1), num2)

## Test case for multiply() function with float type inputs
#  @param num1 Floating point number
#  @param num2 Floating point number
@settings(verbosity=Verbosity.verbose)
@given(st.floats(), st.floats())
def test_multiply_floats(num1, num2):
    if isnan(num1 * num2):
        with pytest.raises(ValueError):
            m_func.multiply(num1, num2)
    else:
        # General test
        assert m_func.multiply(num1, num2) == num1 * num2
        # Test Indentity property
        assert m_func.multiply(num1, 1) == num1
        # Test Commutative property
        assert m_func.multiply(num1, num2) == m_func.multiply(num2, num1)

## Test case for divide() function with integer type inputs
#  @param num1 Integer number
#  @param num2 Integer number
@settings(verbosity=Verbosity.verbose)
@given(st.integers(), st.integers())
def test_divide_integers(num1, num2):
    if num2 == 0:
        with pytest.raises(ZeroDivisionError):
            m_func.divide(num1, num2)
    else:
        # General test
        assert m_func.divide(num1, num2) == num1 / num2
        # Test Indentity property
        assert pytest.approx(m_func.divide(num1, 1)) == num1
        # Number divided by itself is equal 1
        if num1 != 0:
            assert m_func.divide(num1, num1) == 1

## Test case for divide() function with float type inputs
#  @param num1 Floating point number
#  @param num2 Floating point number
@settings(verbosity=Verbosity.verbose)
@given(st.floats(), st.floats())
def test_divide_floats(num1, num2):
    if num2 == 0:
        with pytest.raises(ZeroDivisionError):
            m_func.divide(num1, num2)
    else:
        if isnan(num1 / num2):
            with pytest.raises(ValueError):
                m_func.divide(num1, num2)
        else:
            # General test
            assert m_func.divide(num1, num2) == num1 / num2
            # Test Indentity property
            assert pytest.approx(m_func.divide(num1, 1)) == num1
            # Number divided by itself is equal 1
            if num1 != 0 and not isnan(num1 / num1):
                assert m_func.divide(num1, num1) == 1

## Test case for factorial() function
#  @param num1 Integer number >= 0 and <= 25000, max value set because of speed
@settings(verbosity=Verbosity.verbose)
@given(st.integers(min_value=0, max_value=25000))
def test_factorial(num1):
    # General test
    assert m_func.factorial(num1) == factorial(num1)
    # Factorial of one equals one
    assert m_func.factorial(1) == 1
    # Factorial of zero equals one
    assert m_func.factorial(0) == 1
    with pytest.raises(ValueError):
        m_func.factorial(-1)
        m_func.factorial(1.5)

## Test case for exponenttiation() function with integer values
#  @param num1 Integer number
#  @param num1 Integer greater or equal than zero
@settings(verbosity=Verbosity.verbose)
@given(st.integers(), st.integers(min_value=0))
def test_exponentiation_integers(num1, num2):
    try:
        # General test
        assert m_func.exponentiation(num1, num2) == pow(num1, num2)
        # Test Indentity property
        assert pytest.approx(m_func.exponentiation(num1, 1)) == num1
        # Number to power of 0 equals one
        assert m_func.exponentiation(num1, 0) == 1
        with pytest.raises(ValueError):
            m_func.exponentiation(num1, -1)
    except OverflowError:
        assume(False)

## Test case for exponenttiation() function with float values
#  @param num1 Float number
#  @param num1 Float greater or equal than zero
@settings(verbosity=Verbosity.verbose)
@given(st.floats(), st.integers(min_value=0))
def test_exponentiation_floats(num1, num2):
    try:
        if isnan(pow(num1, num2)):
            with pytest.raises(ValueError):
                m_func.exponentiation(num1, num2)
        else:
            # General test
            assert m_func.exponentiation(num1, num2) == pow(num1, num2)
            # Test Indentity property
            if not isnan(num1):
                assert pytest.approx(m_func.exponentiation(num1, 1)) == num1
            # Number to power of 0 equals one
            assert m_func.exponentiation(num1, 0) == 1
            with pytest.raises(ValueError):
                m_func.exponentiation(num1, -1)
    except OverflowError:
        assume(False)

## Test case for root() function with inteeger values
#  @param num1 Integer number, limit because of speed
#  @param num1 Integer number, limit because of speed
@settings(verbosity=Verbosity.verbose, deadline=None)
@given(st.integers(min_value=-25000, max_value=25000), \
    st.integers(min_value=-25000, max_value=25000))
def test_root_integers(num1, num2):
    try:
        if num2 == 0:
            with pytest.raises(ZeroDivisionError):
                m_func.root(num1, num2)
        else:
            if num1 == 0 and num2 < 0:
                with pytest.raises(ZeroDivisionError):
                    m_func.root(num1, num2)
            else:        
                if num1 < 0 and num2 % 2 == 0:
                    with pytest.raises(ValueError):
                        m_func.root(num1, num2)
                else:
                    # General test
                    assert m_func.root(num1, num2) == num1 ** float(1 / num2)
                    # Test Identity property
                    assert m_func.root(num1, 1) == num1
                    # Zero to nth root is zero
                    if num2 >= 0:
                        assert m_func.root(0, num2) == 0
                    # One to nth root is One
                    assert m_func.root(1, num2) == 1
    except OverflowError:
        assume(False)

## Test case for root() function with inteeger values
#  @param num1 Integer number, limit because of speed
#  @param num1 Integer number, limit because of speed
@settings(verbosity=Verbosity.verbose, deadline=None)
@given(st.floats(min_value=-25000, max_value=25000), \
    st.floats(min_value=-25000, max_value=25000))
def test_root_floats(num1, num2):
    try:
        if num2 == 0: 
            with pytest.raises(ZeroDivisionError):
                m_func.root(num1, num2)             
        else:
            if num1 == 0 and num2 < 0:
                with pytest.raises(ZeroDivisionError):
                    m_func.root(num1, num2)
            else:
                if num1 < 0 and num2 % 2 == 0:
                    with pytest.raises(ValueError):
                        m_func.root(num1, num2)
                else:
                    # General test
                    assert m_func.root(num1, num2) == num1 ** float(1 / num2)
                    # Test Identity property
                    assert m_func.root(num1, 1) == num1
                    # Zero to nth root is zero
                    if num2 >= 0:
                        assert m_func.root(0, num2) == 0
                    # One to nth root is One
                    assert m_func.root(1, num2) == 1
    except OverflowError:
        assume(False)

## Test case for int2bin() function
#  @param num1 Integer number
@settings(verbosity=Verbosity.verbose)
@given(st.integers())
def test_int2bin(num1):
    # General test
    assert m_func.int2bin(num1) == bin(num1)
